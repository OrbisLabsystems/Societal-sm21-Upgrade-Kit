{==============================================================================}
{                                                                              }
{  ORBIS INFORMATION SYSTEMS                                                   }
{                                                                              }
{  Filename         : $SMMILL_RESMAP_REM.RPF                                   }
{  Version          : 3.1                                                      }
{  Author           : A. Finnerty                                              }
{  Date Created     : 14-Jul-2006                                              }
{  Description      : Contains routines that allow a result map record         }
{                     be removed                                               }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{                                                                              }
{  Ver.     Date        By          Description                                }
{  ----     ----        --          -----------                                }
{  4.0      20-Dec-2007 AF          Release                                    }
{                                                                              }
{==============================================================================}


ENABLE WINDOWS

SET NAME "DEFER/"
SET NOTPROTECTED

SET COMPILE_OPTION DECLARE

JOIN STANDARD_LIBRARY STD_PROMPT
JOIN STANDARD_LIBRARY STD_ARRAY
JOIN STANDARD_LIBRARY STD_UTILS
JOIN LIBRARY $LIB_UTILS
JOIN LIBRARY $PROMPT_LIST


{========================================================================

  This report can be used as a template for other purposes
  The number of identity prompts can be set between 1 and 5
  (using number_of_prompts global )

  Specify the prompt names using LBL_IDENTITY constants
  The ROUTINE_LIST_IDENTITY routines are used to set the routines that fill the identities
  The ROUTINE_ONOK routine is called when OK is pressed. It returns True/False for validation
  and carries out the action. It accepts N parameters where N is number of identities

  A global routine may be written that waps main_form_initialisation (which is 
  not global as there may be > 1 reports using this template). This will allow this 
  form to be automatically populated (e.g. if calling from another screen e.g. SM-Millennium explorer )

==============================================================================}


{ form }
CONSTANT ID_PROMPT_WIDTH = 30


{ Routines }
CONSTANT ROUTINE_LIST_IDENTITY1 = "get_db_link_list"
CONSTANT ROUTINE_LIST_IDENTITY2 = "get_entity_list"
CONSTANT ROUTINE_LIST_IDENTITY3 = "get_mapped_anal_list"
CONSTANT ROUTINE_LIST_IDENTITY4 = "get_mapped_anal_ver_list"
CONSTANT ROUTINE_LIST_IDENTITY5 = ""
CONSTANT ROUTINE_ONOK = "update_res_map"



{ Labels }
DECLARE LBL_CAPTION_REMOVE,LBL_CAPTION_RESTORE,
LBL_IDENTITY1,LBL_IDENTITY2,LBL_IDENTITY3,LBL_IDENTITY4,LBL_IDENTITY5


{ Other constants }
CONSTANT WRITE_TRANS_NAME 		= "SM-Millennium Interface"



{ Tags so prompt index is known for prompt objects  }
DECLARE prompt_tag_array, g_number_of_prompts, g_start_time
DECLARE g_is_remove


remove_option (1)
restore_option (1)


ROUTINE remove_option (VALUE option)

   g_number_of_prompts = 4
   g_is_remove = TRUE

   main_form_run  ()

ENDROUTINE 


ROUTINE restore_option (VALUE option)

   g_number_of_prompts = 4
   g_is_remove = FALSE

   main_form_run  ()

ENDROUTINE 



{==============================================================================}
{                                                                              }
{  ROUTINE main_form_run                                                       }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  07/07/04     AF              Runs the main form                             }
{                                                                              }
{==============================================================================}

ROUTINE main_form_run  

    LBL_CAPTION_REMOVE = GET_USER_MESSAGE ("MILL_LTRR_LBL_CAPTION_REMOVE",1)
    LBL_CAPTION_RESTORE = GET_USER_MESSAGE ("MILL_LTRR_LBL_CAPTION_RESTORE",1)
    LBL_IDENTITY1 = GET_USER_MESSAGE ("MILL_LTRR_LBL_IDENTITY1",1)
    LBL_IDENTITY2 = GET_USER_MESSAGE ("MILL_LTRR_LBL_IDENTITY2",1)
    LBL_IDENTITY3 = GET_USER_MESSAGE ("MILL_LTRR_LBL_IDENTITY3",1)
    LBL_IDENTITY4 = GET_USER_MESSAGE ("MILL_LTRR_LBL_IDENTITY4",1)
    LBL_IDENTITY5 = ""


   main_form_initialisation (0, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY)

ENDROUTINE   {   main_form_run   }




{==============================================================================}
{                                                                              }
{  ROUTINE main_form_initialisation                                            }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  07/07/04     AF              Initialise the prompt Libraries                }
{                                                                              }
{==============================================================================}

ROUTINE main_form_initialisation (VALUE num_prompts, VALUE id1, VALUE id2, VALUE id3,
                                                     VALUE id4, VALUE id5 )
     
    set_up_std_prompt_list_class ( ) 

    DECLARE form

    { prompt_tag_array is a global, but dim as array here, so can call this from other routines }
    ARRAY prompt_tag_array   ARRAYSIZE (0)
    
    { To get around problem with menu proc, (validates form automatically) dont allow
       form validation unless oipen for >2 seconds
    }
    g_start_time = NOW

    { Can optionally set number of prompts global from here }
    IF (num_prompts > 0) THEN

        g_number_of_prompts = num_prompts

    ENDIF

    create_form_main_form ( form )


    { initial values }
    IF (id1 <> EMPTY) THEN

	array_insert_slice (form.prompt_objects [prompt_tag_array [1]].choose_array,1,1)
	form.prompt_objects [prompt_tag_array [1]].choose_array [1,1] = PAD (id1, " ", ID_PROMPT_WIDTH)
	form.prompt_objects [prompt_tag_array [1]].choose_array [1,2] = id1

    ENDIF

    IF (id2 <> EMPTY) THEN

	array_insert_slice (form.prompt_objects [prompt_tag_array [2]].choose_array,1,1)
	form.prompt_objects [prompt_tag_array [2]].choose_array [1,1] = PAD (id2, " ", ID_PROMPT_WIDTH)
	form.prompt_objects [prompt_tag_array [2]].choose_array [1,2] = id2

    ENDIF

    IF (id3 <> EMPTY) THEN

	array_insert_slice (form.prompt_objects [prompt_tag_array [3]].choose_array,1,1)
	form.prompt_objects [prompt_tag_array [3]].choose_array [1,1] = PAD (id3, " ", ID_PROMPT_WIDTH)
	form.prompt_objects [prompt_tag_array [3]].choose_array [1,2] = id3

    ENDIF

    IF (id4 <> EMPTY) THEN

	array_insert_slice (form.prompt_objects [prompt_tag_array [4]].choose_array,1,1)
	form.prompt_objects [prompt_tag_array [4]].choose_array [1,1] = PAD (id4, " ", ID_PROMPT_WIDTH)
	form.prompt_objects [prompt_tag_array [4]].choose_array [1,2] = id4

    ENDIF


  IF (id5 <> EMPTY) THEN

	array_insert_slice (form.prompt_objects [prompt_tag_array [5]].choose_array,1,1)
	form.prompt_objects [prompt_tag_array [5]].choose_array [1,1] = PAD (id5, " ", ID_PROMPT_WIDTH)
	form.prompt_objects [prompt_tag_array [5]].choose_array [1,2] = id5

    ENDIF

    form . start_prompt ( ) 
    form . wait_prompt  ( ) 
    form . end_prompt   ( )


ENDROUTINE   {   main_form_initialisation   }




{==============================================================================}
{                                                                              }
{  ROUTINE create_form_main_form                                               }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  07/07/04     AF              creates main form                              }
{                                                                              }
{==============================================================================}

ROUTINE create_form_main_form ( form ) 

    DECLARE id1_array

    ARRAY id1_array    ARRAYSIZE (0,2)

  
    {  The form }
    PROMPT OBJECT form CLASS "STD_FORM"

    IF (g_is_remove) THEN
        form . header               = LBL_CAPTION_REMOVE
    ELSE
        form . header               = LBL_CAPTION_RESTORE
    ENDIF


    form . row                  = 5
    form . column               = 20
    form . height               = 3 * g_number_of_prompts
    form . width                = 37
    form . vgl_library          = global ( "current_library" )
    form . validation_routine   = "main_form_validation"
    form . button_style         = FORM_BUTTON_OK_CANCEL
    form . return_behaviour     = FORM_RETURN_LEAVE


    form.add_frame ("",2,1,3 * g_number_of_prompts,35)  



    {  Create identity prompts, they must be created in correct order - id 1 first, ..... }

    create_prompt (form,  LBL_IDENTITY1, 1)
      

    {   fill identity prompt }

    CALL_ROUTINE ROUTINE_LIST_IDENTITY1
                 USING id1_array

    form . prompt_objects [prompt_tag_array [1]] . choose_array = id1_array

    ensure_default_prompt (form . prompt_objects [prompt_tag_array [1]].choose_array)
 
    IF (g_number_of_prompts > 1) THEN

        create_prompt (form,  LBL_IDENTITY2, 2)
        ensure_default_prompt (form . prompt_objects [prompt_tag_array [2]].choose_array)

    ENDIF


    IF (g_number_of_prompts > 2) THEN

        create_prompt (form,  LBL_IDENTITY3, 3)
        ensure_default_prompt (form . prompt_objects [prompt_tag_array [3]].choose_array)
 
    ENDIF

    IF (g_number_of_prompts > 3) THEN

        create_prompt (form,  LBL_IDENTITY4, 4)
        ensure_default_prompt (form . prompt_objects [prompt_tag_array [4]].choose_array)

    ENDIF


    IF (g_number_of_prompts > 4) THEN

        create_prompt (form,  LBL_IDENTITY5, 5)
        ensure_default_prompt (form . prompt_objects [prompt_tag_array [5]].choose_array)

    ENDIF

ENDROUTINE  {  create_form_main_form  }




{==============================================================================}
{                                                                              }
{  ROUTINE create_prompt                                                       }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  07/07/04     AF              creates one prompt                             }
{                                                                              }
{==============================================================================}

ROUTINE create_prompt (form, VALUE name, VALUE id_number)

    DECLARE prompt_object, id_cnt_text
  
    PROMPT OBJECT prompt_object CLASS "STD_PROMPT_TEXT_CHOOSE"

    ARRAY prompt_object.choose_array    
  
    { need numeric form of id number }
    id_cnt_text = STRIP( id_number )

    form . add_display ( name, 3 , ((id_number-1) * 3) + 1, PROMPT_RENDITION_NORMAL ) 

    prompt_object . value                = ""
    prompt_object . row                  = ((id_number-1) * 3) + 2
    prompt_object . column               = 4
    prompt_object . height               = 1
    prompt_object . width                = ID_PROMPT_WIDTH
    prompt_object . vgl_library          = global ( "current_library" )
    prompt_object . leave_prompt_routine = "prompt_identity":id_cnt_text:"_leave_prompt"
    prompt_object . is_spin              = FALSE


    {
        If need other callbacks, use the following:

            prompt_object . browse_routine       = "prompt_identity":id_cnt_text:"_browse"
            prompt_object . enter_prompt_routine = "prompt_identity":id_cnt_text:"_enter_prompt"
            prompt_object . leave_prompt_routine = "prompt_identity":id_cnt_text:"_leave_prompt"
            prompt_object . validation_routine   = "prompt_identity":id_cnt_text:"_validation"
            prompt_object . select_routine       = "prompt_identity":id_cnt_text:"_select"
            prompt_object . key_press_routine    = "prompt_identity":id_cnt_text:"_key_press"
    }


    {  store the tag  }
    prompt_tag_array [ size_of_array (prompt_tag_array) + 1 ] = form . add_prompt ( prompt_object)

ENDROUTINE    {  create_prompt  }




{---------------- Callbacks for prompt main_form  ------------------------}

{==============================================================================}
{                                                                              }
{  ROUTINE main_form_validation                                                }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  07/07/04     AF              Validation routine, called when click OK       }
{                                                                              }
{==============================================================================}

ROUTINE main_form_validation ( self ) 

    DECLARE is_valid

    { To get around problem with menu proc, (validates form automatically) dont allow
       form validation unless oipen for >2 seconds
    }
    IF ((NOW - g_start_time) < INTERVAL ("0000 00:00:02")) THEN

        RETURN (FALSE)

    ENDIF


    IF (g_number_of_prompts = 1) THEN

        CALL_ROUTINE ROUTINE_ONOK
                 USING self . prompt_objects [prompt_tag_array [1]] . value 
                 RETURNING is_valid
    ENDIF


    IF (g_number_of_prompts = 2) THEN

        CALL_ROUTINE ROUTINE_ONOK
                 USING self . prompt_objects [prompt_tag_array [1]] . value , 
                       self . prompt_objects [prompt_tag_array [2]] . value 
                 RETURNING is_valid
    ENDIF

    IF (g_number_of_prompts = 3) THEN

        CALL_ROUTINE ROUTINE_ONOK
                 USING self . prompt_objects [prompt_tag_array [1]] . value , 
                       self . prompt_objects [prompt_tag_array [2]] . value ,
                       self . prompt_objects [prompt_tag_array [3]] . value 
                 RETURNING is_valid
    ENDIF

    IF (g_number_of_prompts = 4) THEN

        CALL_ROUTINE ROUTINE_ONOK
                 USING self . prompt_objects [prompt_tag_array [1]] . value , 
                       self . prompt_objects [prompt_tag_array [2]] . value ,
                       self . prompt_objects [prompt_tag_array [3]] . value ,
                       self . prompt_objects [prompt_tag_array [4]] . value
                 RETURNING is_valid

    ENDIF


    IF (g_number_of_prompts = 5) THEN

        CALL_ROUTINE ROUTINE_ONOK
                 USING self . prompt_objects [prompt_tag_array [1]] . value , 
                       self . prompt_objects [prompt_tag_array [2]] . value ,
                       self . prompt_objects [prompt_tag_array [3]] . value ,
                       self . prompt_objects [prompt_tag_array [4]] . value ,
                       self . prompt_objects [prompt_tag_array [5]] . value
                 RETURNING is_valid

    ENDIF


    RETURN ( is_valid )

ENDROUTINE

  

{----------  Callbacks for identity1 prompt  ----------------------}




{==============================================================================}
{                                                                              }
{  ROUTINE prompt_identity1_leave_prompt                                       }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  07/07/04     AF              Called when leave identity1 prompt             }
{                                                                              }
{==============================================================================}

ROUTINE prompt_identity1_leave_prompt ( self ) 

    IF ( g_number_of_prompts > 1) THEN

        empty_the_array (self . parent_prompt . prompt_objects [prompt_tag_array [2]].choose_array)
        ensure_default_prompt (self . parent_prompt . prompt_objects [prompt_tag_array [2]].choose_array)

    ENDIF

    IF ( g_number_of_prompts > 2) THEN

        empty_the_array (self . parent_prompt . prompt_objects [prompt_tag_array [3]].choose_array)
        ensure_default_prompt (self . parent_prompt . prompt_objects [prompt_tag_array [3]].choose_array)
    
    ENDIF

    IF ( g_number_of_prompts > 3) THEN

        empty_the_array (self . parent_prompt . prompt_objects [prompt_tag_array [4]].choose_array)
        ensure_default_prompt (self . parent_prompt . prompt_objects [prompt_tag_array [4]].choose_array)
    
    ENDIF

    IF ( g_number_of_prompts > 4) THEN

        empty_the_array (self . parent_prompt . prompt_objects [prompt_tag_array [5]].choose_array)
        ensure_default_prompt (self . parent_prompt . prompt_objects [prompt_tag_array [5]].choose_array)
    
    ENDIF

    IF ( g_number_of_prompts > 1) THEN

        CALL_ROUTINE ROUTINE_LIST_IDENTITY2
                 USING self . parent_prompt . prompt_objects [prompt_tag_array [2]].choose_array,
                       self.value

   ENDIF

ENDROUTINE   {  prompt_identity1_leave_prompt  }




{----------  Callbacks for identity2 prompt  ----------------------}



{==============================================================================}
{                                                                              }
{  ROUTINE prompt_identity2_leave_prompt                                       }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  07/07/04     AF              Called when leave identity2 prompt             }
{                                                                              }
{==============================================================================}

ROUTINE prompt_identity2_leave_prompt ( self ) 

    IF ( g_number_of_prompts > 2) THEN

        empty_the_array (self . parent_prompt . prompt_objects [prompt_tag_array [3]].choose_array)
        ensure_default_prompt (self . parent_prompt . prompt_objects [prompt_tag_array [3]].choose_array)
    
    ENDIF

    IF ( g_number_of_prompts > 3) THEN

        empty_the_array (self . parent_prompt . prompt_objects [prompt_tag_array [4]].choose_array)
        ensure_default_prompt (self . parent_prompt . prompt_objects [prompt_tag_array [4]].choose_array)
    
    ENDIF


    IF ( g_number_of_prompts > 4) THEN

        empty_the_array (self . parent_prompt . prompt_objects [prompt_tag_array [5]].choose_array)
        ensure_default_prompt (self . parent_prompt . prompt_objects [prompt_tag_array [5]].choose_array)
    
    ENDIF


    IF ( g_number_of_prompts > 2) THEN

        CALL_ROUTINE ROUTINE_LIST_IDENTITY3
                 USING self . parent_prompt . prompt_objects [prompt_tag_array [3]] .choose_array,
                       self . parent_prompt . prompt_objects [prompt_tag_array [1]] . value, 
                       self.value

    ENDIF

ENDROUTINE    




{----------  Callbacks for identity3 prompt  ----------------------}



{==============================================================================}
{                                                                              }
{  ROUTINE prompt_identity3_leave_prompt                                       }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  07/07/04     AF              Called when leave identity3 prompt             }
{                                                                              }
{==============================================================================}

ROUTINE prompt_identity3_leave_prompt ( self ) 


    IF ( g_number_of_prompts > 3) THEN

        empty_the_array (self . parent_prompt . prompt_objects [prompt_tag_array [4]].choose_array)
        ensure_default_prompt (self . parent_prompt . prompt_objects [prompt_tag_array [4]].choose_array)

    ENDIF


    IF ( g_number_of_prompts > 4) THEN

        empty_the_array (self . parent_prompt . prompt_objects [prompt_tag_array [5]].choose_array)
        ensure_default_prompt (self . parent_prompt . prompt_objects [prompt_tag_array [5]].choose_array)
    
    ENDIF

   IF ( g_number_of_prompts > 3) THEN
 

        CALL_ROUTINE ROUTINE_LIST_IDENTITY4
                 USING self . parent_prompt . prompt_objects [prompt_tag_array [4]] .choose_array,
                       self . parent_prompt . prompt_objects [prompt_tag_array [1]] . value, 
                       self . parent_prompt . prompt_objects [prompt_tag_array [2]] . value, 
                       self.value
    ENDIF


ENDROUTINE    





{----------  Callbacks for identity4 prompt  ----------------------}




{==============================================================================}
{                                                                              }
{  ROUTINE prompt_identity4_leave_prompt                                       }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  07/07/04     AF              Called when leave identity4 prompt             }
{                                                                              }
{==============================================================================}

ROUTINE prompt_identity4_leave_prompt ( self ) 


    IF ( g_number_of_prompts > 4) THEN

        empty_the_array (self . parent_prompt . prompt_objects [prompt_tag_array [5]].choose_array)
        ensure_default_prompt (self . parent_prompt . prompt_objects [prompt_tag_array [5]].choose_array)
    

        CALL_ROUTINE ROUTINE_LIST_IDENTITY5
                 USING self . parent_prompt . prompt_objects [prompt_tag_array [5]] .choose_array,
                       self . parent_prompt . prompt_objects [prompt_tag_array [1]] . value, 
                       self . parent_prompt . prompt_objects [prompt_tag_array [2]] . value, 
                       self . parent_prompt . prompt_objects [prompt_tag_array [3]] . value, 
                       self.value
    ENDIF

ENDROUTINE    



{----------  Callbacks for identity5 prompt  ----------------------}




{==============================================================================}
{                                                                              }
{  ROUTINE prompt_identity5_leave_prompt                                       }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  07/07/04     AF              Called when leave identity5 prompt             }
{                                                                              }
{==============================================================================}

ROUTINE prompt_identity5_leave_prompt ( self ) 

ENDROUTINE    



{ ----------------- end of callbacks  ------------------}



{==============================================================================}
{                                                                              }
{  ROUTINE ensure_default_prompt                                               }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  09-JUL-2004  AF              If a prompt array is empty, ensures "-----" is }
{                               not displayed                                  }
{                                                                              }
{==============================================================================}

ROUTINE ensure_default_prompt (prompt_array)

   IF (size_of_array (prompt_array) = 0) THEN

       prompt_array [1,1] = ""
       prompt_array [1,2] = EMPTY

   ELSE

      { This is only required for SM2000 because the prompt window shrinks to 
        length of longest display text
      }
      prompt_array [1,1] = PAD ( prompt_array [1,1], " ", ID_PROMPT_WIDTH)

   ENDIF

ENDROUTINE     {  ensure_default_prompt  }



{==============================================================================}
{                                                                              }
{  ROUTINE empty_the_array                                                     }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  09-JUL-2004  AF             emptys an array                                 }
{                                                                              }
{==============================================================================}

ROUTINE empty_the_array  (the_array)

   DECLARE i

   i = size_of_array (the_array)
   WHILE (i > 0) DO

      array_remove_slice (the_array, 1, i)   
      i = i - 1

   ENDWHILE

ENDROUTINE     { empty_the_array  }



{==============================================================================}
{                                                                              }
{  ROUTINE check_write_transaction                                             }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  17-DEC-1997  ER              This checks if the process is already in a     }
{                               write_transaction, and if not, starts one.     }
{                                                                              }
{==============================================================================}

ROUTINE check_write_transaction

    IF NOT transaction_is_write() THEN

       START WRITE TRANSACTION WRITE_TRANS_NAME

    ENDIF

ENDROUTINE




{==============================================================================}
{                                                                              }
{  ROUTINE get_db_link_list                                                    }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  08/07/04     AF              Gets list of database links                    }
{                                                                              }
{==============================================================================}

ROUTINE get_db_link_list  (id_array)

   DECLARE id, i

   id = SELECT DISTINCT mill_component_map_hdr. database_link

    i = 0
    WHILE (id <> EMPTY) DO

        IF (STRIP(id) <> "") THEN

           i = i + 1
           id_array [i,1] = id
           id_array [i,2] = id

        ENDIF
 
        NEXT mill_component_map_hdr
        id = SELECT mill_component_map_hdr. database_link

    ENDWHILE

ENDROUTINE   {  get_db_link_list }



{==============================================================================}
{                                                                              }
{  ROUTINE get_entity_list                                                     }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  08/07/04     AF              Gets list of mapped entities for database links}
{                                                                              }
{==============================================================================}

ROUTINE get_entity_list  (id_array, dblink)

    DECLARE id, i

    IF (dblink = EMPTY) THEN

       RETURN

    ENDIF

    id = SELECT DISTINCT mill_component_map_hdr . mill_entity
                  WHERE database_link = dblink
                    AND removeflag = NOT g_is_remove


    i = 0
    WHILE (id <> EMPTY) DO

        i = i + 1
        id_array [i,1] = id
        id_array [i,2] = id

        NEXT mill_component_map_hdr
        id = SELECT mill_component_map_hdr . mill_entity

    ENDWHILE

ENDROUTINE    {  get_entity_list  }



{==============================================================================}
{                                                                              }
{  ROUTINE get_mapped_anal_list                                                }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  08/07/04     AF              Gets list of mapped analysis that fits criteria}
{                                                                              }
{==============================================================================}

ROUTINE get_mapped_anal_list (id_array, db_link, entity)

    DECLARE id, i


   IF (dblink = EMPTY) OR (entity = EMPTY) THEN

       RETURN

    ENDIF


    id = SELECT DISTINCT mill_component_map_hdr . analysis
                  WHERE database_link = dblink
		    AND mill_entity = entity
                    AND removeflag = NOT g_is_remove

    i = 0
    WHILE (id <> EMPTY) DO

        i = i + 1
        id_array [i,1] = id
        id_array [i,2] = id

        NEXT mill_component_map_hdr 
        id = SELECT mill_component_map_hdr . analysis

    ENDWHILE

ENDROUTINE    {  get_mapped_anal_list  }



{==============================================================================}
{                                                                              }
{  ROUTINE get_mapped_anal_ver_list                                            }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  08/07/04     AF              Get list of analysis version that fits criteria}
{                                                                              }
{==============================================================================}

ROUTINE get_mapped_anal_ver_list (id_array, db_link, entity, the_anal)

    DECLARE id, i


   IF (dblink = EMPTY) OR (entity = EMPTY) OR
       (the_anal = EMPTY) THEN

       RETURN

    ENDIF

   id = SELECT DISTINCT mill_component_map_hdr . analysis_version
                  WHERE database_link = dblink
		    AND mill_entity = entity
		    AND analysis = the_anal
                    AND removeflag = NOT g_is_remove

    i = 0
    WHILE (id <> EMPTY) DO

        i = i + 1
        id_array [i,1] = id
        id_array [i,2] = id

        NEXT mill_component_map_hdr  
        id = SELECT mill_component_map_hdr . analysis_version

    ENDWHILE

ENDROUTINE    {  get_mapped_anal_ver_list  }




{==============================================================================}
{                                                                              }
{  ROUTINE update_res_map                                                      }
{                                                                              }
{==============================================================================}
{                                                                              }
{  Modification History                                                        }
{  --------------------                                                        }
{                                                                              }
{  Date         By              Description                                    }
{  ----         --              -----------                                    }
{  08/07/04     AF              Called from send to update result              }
{                                                                              }
{==============================================================================}

ROUTINE update_res_map (db_link, entity, anal, anal_ver)

    DECLARE rec, do_it
 
    do_it = FALSE

    { Check for no new version first}
   IF (dblink = EMPTY) OR (entity = EMPTY) OR
       (anal = EMPTY) OR (anal_ver = EMPTY) THEN

        flashmessage (GET_USER_MESSAGE ("MILL_LTRR_PROMPTS_NOT_POPULATE",1), TRUE)

        RETURN (FALSE)

    ENDIF


  
    IF (g_is_remove) THEN

        IF (confirm_with_text (GET_USER_MESSAGE ("MILL_LTRR_WANT_REM",1))) THEN           
            do_it = TRUE
        ENDIF
    ELSE

        IF (confirm_with_text ( GET_USER_MESSAGE ("MILL_LTRR_WANT_RESTORE",1) )) THEN
            do_it = TRUE
        ENDIF

    ENDIF

    IF (do_it) THEN

        rec = SELECT mill_component_map_hdr . database_link    FOR UPDATE
                             WHERE database_link = dblink
		               AND mill_entity = entity
		               AND analysis = anal
		               AND analysis_version = anal_ver
                               AND removeflag = NOT g_is_remove

         IF (rec = LOCKED) THEN
              flashmessage ("Record is locked", TRUE)
         ELSE
               check_write_transaction ()
               ASSIGN mill_component_map_hdr . removeflag  = g_is_remove
               ASSIGN mill_component_map_hdr . modified_on = NOW
               ASSIGN mill_component_map_hdr . modified_by = GLOBAL ("operator")

               UPDATE mill_component_map_hdr
               COMMIT
         ENDIF

    ENDIF


    RETURN (TRUE)

ENDROUTINE    {  update_res_map }



